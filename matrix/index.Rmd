---
title: "Ecologisch functioneren"
subtitle: "Matrix reloaded 2022"
author: "Laura Moria"
always_allow_html: yes
delete_merged_file: TRUE
date: "`r Sys.Date()`"
site: bookdown::bookdown_site
output:
  bookdown::html_book:
    theme: sandstone
    split_by: none
documentclass: book
---

```{r global, include = FALSE}
#  Settings-------------------------------------------------------
rm(list=ls())                               #maakt geheugen leeg voor aanvang
chooseCRANmirror(graphics=FALSE, ind=1)
knitr::opts_chunk$set(echo = TRUE)
dirGIS <-"../GIS"

# Load packages and functions-------------------------------------
source('../scripts/ppr_funs.R')
source('../scripts/calc_funs.R')

# require packages
require(data.table);require(sf);require(dplyr); require(rgeos)

# other settings
proj4.rd <- 28992
proj4.google <-4326

# run for pdf and word
# bookdown::render_book("index.Rmd", "bookdown::word_document2")
# bookdown::render_book("index.Rmd", "bookdown::pdf_book")
```

```{r data, include = FALSE}
# inladen basis bestanden ----

# output wsa --------
# read in the latest version of ESFoordelen from 'data'
ESFoordelen <- ppr_esf_oordeel(dir = '../data')

# informatie over maatregelen
maatregelen <- ppr_maatregelen(dir = '../data')

# geoinfo -----------
# shape met alle EAGs
EAG <- sf::st_read("../data/EAG20210709.gpkg",quiet = T) %>% sf::st_transform(proj4.rd)
# shape met al het water in EAG
waterpereag <- sf::st_read("../data/WaterPerEAG_20210709.gpkg",quiet = T) %>% sf::st_transform(proj4.rd)

# domeintabellen ------
# water types
watertypen <- data.table::fread('../data/KRWWatertype.csv')

# locaties van alle metingen (water, biologie, en slootbodem)
locaties <- data.table::fread('../data/Location.csv')

## aanvullende eag data, krwwatertype niet overal ingevuld en stedelijk landelijk voor EST
eag_wl <- data.table::fread('../data/EAG_Opp_kenmerken_20201208.csv')
eag_wl <- eag_wl[is.na(eag_wl$Einddatum),] #alleen actuele grenzen

# pclakeditch en balansen -------
# nonogram
nomogram <- data.table::fread('../data/nomogram.csv')

# datafile with P-load PC Ditch
Overzicht_kP <- data.table::fread('../data/Overzicht_kP.csv')
Overzicht_kP <- ppr_pcditch(db = Overzicht_kP)

# waterbalans data (made by loadBalances)
# load waterbalances (only when needed)
if(FALSE){dat <- loadBalances_lm(dir_bal = dir_bal, kopTab = kopTab, sfile = FALSE)}
dat <- readRDS("../pbelasting/dat.rds")  
dat[,date := as.POSIXct(paste0(jaar,"-",maand,"-01"), format = '%Y-%m-%d')]

# waterkwaliteitsdata ------------
simoni <- readRDS('../data/simoni.rds')
wq  <- readRDS("../data/ImportWQ.rds") %>% as.data.table()
wq <-  ppr_wq(db = wq, syear = 2000, wtype = eag_wl, mlocs = locaties, srow= c("IONEN|NUTRI|ALG|VELD|ALGEN|LICHT|MONSVAR"))   

# KRW beoordeling ---------------
# KRW doelen 
doelen <- ppr_doelen(dir = '../hydrobiologie')

# EKR sets KRW en overig water
EKRset1 <- readRDS('../hydrobiologie/EKRsetKRW.rds') %>% as.data.table()
EKRset2 <- readRDS('../hydrobiologie/EKRsetOvWater.rds') %>% as.data.table()
EKRset <- ppr_ekr(krwset = EKRset1, ovwatset = EKRset2,eag_wl = eag_wl, doelen = doelen)

# gegevens hydrobiologie ---------------
hybi <- readRDS('../data/alles_reliable.rds') %>% as.data.table()
hybi <- ppr_hybi(db = hybi, syear = 2000, wtype = eag_wl, mlocs = locaties)

    
# slootbodem measurements ---------------
bod  <- fread("../data/bodemfews.csv")
bod <- ppr_slootbodem(db = bod, wtype = eag_wl, mlocs = locaties)
    
```

```{r update filter and clean up databases, include = FALSE}
# calculate means per EAG -----------
# calculate mean EKR per EAG from last 3 measured years
krw <- calc_mean_EKR(db = EKRset, nyears = 3, pEAG = TRUE, pYEAR = FALSE, pSEASON = FALSE)
# rename GHPR in more readible (and less long names)
krw[,GPHRnew := renameGHPR(GHPR)]
krw[,wbmethode := renameWbmethode(wbmethode)]
    
# remove all data rows without EAGIDENT, alleen ongewogen scores selecteren
krw <- krw[!is.na(EAGIDENT)]
# dcast om maatlatten aprt te beschouwen en relaties tussen maatlatten te leggen
krw <- dcast(krw, EAGIDENT + id + watertype ~ GPHRnew + wbmethode, 
                 value.var = "EKR", fun.aggregate = mean)
# add GAF code
krw[,GAF := substr(EAGIDENT, 1, 4)]
    
# pvskp 
PvskP <- makePmaps(dbwbal = dat, dbhybi = hybi, dbnomogram = nomogram,
                       dbov_kP = Overzicht_kP, dbeag_wl = eag_wl)

# bodem toevoegen 
gemwaterbod <- bodsam(bod,cmean = TRUE)
    
# hybi indicatoren matrix maken obv mediaan per gebied en gemiddelde over jaren van laatste drie meetjaren
d4 <- calcMeanHybi(hybi = hybi, pEAG =T, pYEAR = T)
# a, b g diversiteit per eag per jaar
hybi.div <- calcNtax(hybi = hybi, nyears = 20, smonth = 1:12, pEAG = T, pYEAR = TRUE, pSEASON = FALSE)

# todo
# compartiment EZ of OW_belangrijk bij koppeling hybi, fysische kenmerken en ekr, bij meren en plassen, sloten zijn alleen EZ
# kop chemie 3 jaar voorafgaand aan hybi en ekr obv gemeten jaren ipv laatste jaren

# mean wq syear-lastdate  
wq1 <- dcast(wq1,locatie.EAG ~ fewsparameter+fewsparameterparameterfractie+fewsparametereenheidequivalent+eenheid, 
                mean, value.var = c("meetwaarde"))
# reset names
colnames(wq1) <- gsub("___|__","_", colnames(wq1))
    
# merge tot matrix -----
matrix1 <- merge(PvskP, krw, by.x = 'EAG', by.y = 'EAGIDENT', all.y = TRUE)
matrix2 <- merge(matrix1,gemwaterbod,by.x = 'EAG', by.y = 'loc.eag', all.x = TRUE)
matrix4 <- merge(matrix2, d4,by.x = 'EAG', by.y = 'locatie.EAG', all.x = TRUE)
matrix5 <- merge(matrix4,wq1, by.x = 'EAG', by.y = 'locatie.EAG', all.x = TRUE)
saveRDS(matrix5,'matrix/201005_matrix.rds')


# calculate means per sampling point and year-----------
    
    # calculate mean EKR per point, season is not correct since date is set to 01-01 for most measures
    krw.mp <- calc_mean_EKR(db = EKRset, nyears = 3,pEAG = FALSE, pYEAR = TRUE, pSEASON = FALSE)
    
    # rename GHPR in more readible (and less long names)
    krw.mp[,GPHRnew := renameGHPR(GHPR)]
    krw.mp[,wbmethode := renameWbmethode(wbmethode)]
    
    # dcast om maatlatten aprt te beschouwen en relaties tussen maatlatten te leggen
    krw.mp.ekr <- dcast(krw.mp, mpid + jaar + watertype + EAGIDENT  + KRW_SGBP3 ~ GPHRnew + wbmethode, 
                        value.var = "EKR", fun.aggregate = mean)
    
    # add GAF code
    krw.mp.ekr[,GAF := substr(EAGIDENT, 1, 4)]

    # update mp-id
    krw.mp.ekr[,mpid2 := tstrsplit(mpid,'_',keep=1)]
    
    # add info for db Locaties
    loc.sel <- locaties[,.(CODE,WATERTYPE,MORFOLOGIE,BODEMSOORT,
                           GAFIDENT,EAGIDENT,OWMIDENT,XCOORD,YCOORD)]
    setnames(loc.sel,paste0('loc_',colnames(loc.sel)))
    krw.mp.ekr <- merge(krw.mp.ekr,loc.sel,by.x = 'mpid2', by.y = 'loc_CODE', all.x = TRUE)
    
    # add info hybi
    hybi.mp <- calcMeanHybi(hybi = hybi, nyears = 20, pEAG = F, pYEAR = T)
    # ntaxa per mp, problem some taxa are only availabe at genus, some at species doublecounting and it 2slow
    hybi.tx.mp <- calcNtax(hybi = hybi, nyears = 20, smonth = 1:12, pEAG = F, pYEAR = TRUE, pSEASON = FALSE)
    
    # add info waterkwaliteitsmetingen, given season and year
    wq.sel <- wq[,.(locatiecode,fewsparameter,meetwaarde,jaar,maand)]
    wq.sel[,season := fifelse(maand %in% 4:10,'summer','winter')]
    wq.sel <- wq.sel[,.(meetwaarde = mean(meetwaarde,na.rm=T)),by=.(locatiecode,fewsparameter,jaar,season)]
    
    # selectie parameters waar minstens 6 metingen beschikbaar zijn
    wq.par <- c('Ptot_mgP_l','PO4_mgP_l_nf',"NO3_mgN_l_nf","Ntot_mgN_l_nf",'NH4_mgN_l_nf',"ZICHT_m","Cl_mg_l" ,
               'O2_mg_l','pH','T_oC','SO4_mg_l',"SO4_mg_l_nf",'CHLFa_ug_l',
               "CHLFa_ug_l_blauwalg" , "Ca_mg_l", "Ca_mg_l_nf",'MGETAL_mgHCO3_l',"MGETAL_mgHCO3_l_nf","Mg_mg_l","Mg_mg_l_nf","ZS_mg_l" )
    wq.sel <- wq.sel[fewsparameter %in% wq.par]
    wq.sel$fewsparameter <- gsub('_nf','',wq.sel$fewsparameter)
    wq.sel <- wq.sel[,fewsparameter := tolower(fewsparameter)]
    wq.sel <- dcast(wq.sel,locatiecode+jaar+season~fewsparameter,value.var = 'meetwaarde')
    
    # search for water quality measurement points that occur within a distance of 1000m and the same EAG
    
      # make wq measurement points spatial
      wq.sel2 <- unique(wq[,.(locatiecode)])
      wq.sel2 <- merge(wq.sel2,loc.sel[,.(loc_CODE,loc_XCOORD,loc_YCOORD,loc_EAGIDENT)],by.x='locatiecode',by.y = 'loc_CODE',all.x = TRUE)
      wq.sel2 <- sf::st_as_sf(wq.sel2,coords = c('loc_XCOORD','loc_YCOORD'),crs = 28992)
      
      # selection sediment measurement points
      wq.sel.bod <- unique(bod[,.(locatiecode)])
      wq.sel.bod <- merge(wq.sel.bod,loc.sel[,.(loc_CODE,loc_XCOORD,loc_YCOORD,loc_EAGIDENT)],
                          by.x='locatiecode',by.y = 'loc_CODE',all.x = TRUE)
      wq.sel.bod <- sf::st_as_sf(wq.sel.bod, coords = c('loc_XCOORD','loc_YCOORD'),crs = 28992)
    
      # make ekr set for each measurement point spatial
      krw.mp.ekr.sf <- unique(krw.mp.ekr[!is.na(loc_XCOORD),.(mpid2,loc_XCOORD,loc_YCOORD,EAGIDENT)])
      krw.mp.ekr.sf <- sf::st_as_sf(krw.mp.ekr.sf,coords = c('loc_XCOORD','loc_YCOORD'),crs = 28992)
  
      # combine both spatial sets with a distance of 1000m and filter on same EAG
      # for loop is slow but I would like the closest (not all within 1 km2) location as well as distance (for filtering later on) per eag
      # round buffer does not work for Vecht and Amstel etc.
      wq.kop <- NULL
      
      for(mp in unique(krw.mp.ekr.sf$mpid2)){
      krw.mp.ekr.sf. <- krw.mp.ekr.sf[krw.mp.ekr.sf$mpid2 == mp,]
      eag <-  krw.mp.ekr.sf.$EAGIDENT
      wq.sel3 <- wq.sel2[wq.sel2$loc_EAGIDENT == eag,]
      if(nrow(wq.sel3) == 0){x <- rbind(cbind(mp,NaN,NaN,eag),wq.kop)}
      if(nrow(wq.sel3) > 0){
      nearest <- wq.sel3$locatiecode[which.min(st_distance(krw.mp.ekr.sf., wq.sel3, byid=TRUE))]
      dist <- min(st_distance(krw.mp.ekr.sf.[krw.mp.ekr.sf.$mpid2 == mp,], wq.sel3, byid=TRUE))
      x <- cbind(mp,nearest,dist,eag)
      wq.kop <- rbind(x, wq.kop)}
      }
      
      wq.kop <- as.data.table(wq.kop)
     
      # koppel met waterkwaliteitsmetingen op basis van jaar en seizoensgemiddelde
      wq.kop.mean <- merge(krw.mp.ekr[,.(mpid2,jaar,season)],wq.kop[,.(mpid2,locatiecode)],by='mpid2',
                           allow.cartesian = TRUE,all.x = TRUE)
      wq.kop.mean <- merge(wq.kop.mean, wq.sel,by=c('locatiecode','jaar','season'),all.x=TRUE)
    
      # krw meetpunten without wq data
      # welke krwlocs hebben geen koppeling, zelfde gaf nemen?
      wq.kop.mean.mis1 <- wq.kop.mean[!is.na(locatiecode)]
      
      
      
    wq.kop.mean <- melt(wq.kop.mean,id.vars = c('mpid2','locatiecode','jaar','season'),variable.name = 'fewsparameter',
                        value.name = 'meetwaarde')
    wq.kop.mean <- wq.kop.mean[!is.na(meetwaarde)]
    wq.kop.mean <- wq.kop.mean[,.(meetwaarde = median(meetwaarde,na.rm=TRUE)),by=.(mpid2,jaar,season,fewsparameter)]
    wq.kop.mean <- dcast(wq.kop.mean,mpid2+jaar+season~fewsparameter,value.var='meetwaarde')
    
    
    
    krw.mp.ekr.fin <- merge(krw.mp.ekr,wq.kop.mean,by=c('mpid2','jaar','season'),all.x = TRUE)
    
    #pvskP
    #bodem closest, interpolatie zou mooier zijn obv script yuki
                        
    
 
        
    
    
```

# ESF versus toestand

In onderstaande figuren zijn verschillende relaties in beeld gebracht door de parameters te kiezen die op de x en y as tegen elkaar worden uitgezet.
Er wordt gekeken naar:

- KRW toetsresultaten waarbij een gemiddelde is genomen van de laatste 3 meetjaren tussen 2006 en 2018
- Gegevens hydrobiologie waarbij een mediaan is genomen van meetlocaties binnen een EAG en een gemiddelde van de laatste 3 meetjaren tussen 2006 en 2018
- Fysisch chemische data waarbij een gemiddelde is genomen van de laatste 3 meetjaren
- Bodemchemische data waarvan een mediaan is genomen van meetlocaties binnen een EAG. Er zijn in verschillende EAG`s monsters beschikbaar uit 2013-2018 gedurende 1 meetjaar.
- Gegevens uit de water- en stoffenbalansen. Gemiddelde van de 96 tot einde balans.

```{r matrix, include=FALSE, message=FALSE, warning=FALSE, echo = FALSE}
#matrix5 <- makeMatrix(EKRset, bod, wq, hybi, dat)

# load data
matrix5 <- readRDS('./matrix.rds')
```


```{r subwatdte,echo = FALSE, fig.cap='Relatie submerse bedekking en waterdiepte.', message=FALSE, warning=FALSE}
diepteVegetatie(hybi, hybiparameter = c('SUBMSPTN','FLAB', 'WATDTE'))
```

```{r m8, fig.cap= "relatie tussen ESF1 variablen in EAGs met watertype M8", message=FALSE, warning=FALSE, echo = FALSE}
matrixset <- matrix5[,c("EAG","KRWwatertype.code.y","Soortensamenstelling macrofyten Hydrofyten_Maatlatten2018 Ov. waterflora","bedsubmers","CHLFA_ug/l", "PvskPDitch","wp_min_sum","nlvrFW","P_P_mg/l")]
matrixM8 <- matrixset[matrixset$KRWwatertype.code.y %in% 'M8',]
nums <- unlist(lapply(matrixM8, is.numeric))  
matrixM8 <- matrixM8[ , nums]
pairs(matrixM8)
```

```{r, fig.cap= "relatie tussen ESF2 variablen in EAGs met watertype M8",  message=FALSE, warning=FALSE, echo = FALSE}
matrixset <- matrix5[,c("EAG","KRWwatertype.code.y","Soortensamenstelling macrofyten Hydrofyten_Maatlatten2018 Ov. waterflora","bedsubmers","PO4_nf_P_mg/l","dieptedoorzicht")]
matrixM8 <- matrixset[matrixset$KRWwatertype.code.y %in% 'M8',]
nums <- unlist(lapply(matrixM8, is.numeric))  
matrixM8 <- matrixM8[ , nums]
pairs(matrixM8)
```

```{r, fig.cap= "relatie tussen ESF3 variablen in EAGs met watertype M8", message=FALSE, warning=FALSE, echo = FALSE}
matrixset <- matrix5[,c("EAG","KRWwatertype.code.y","Soortensamenstelling macrofyten Hydrofyten_Maatlatten2018 Ov. waterflora","bedsubmers","Ptot_gP/kg_dg_BS")]
matrixM8 <- matrixset[matrixset$KRWwatertype.code.y %in% 'M8',]
nums <- unlist(lapply(matrixM8, is.numeric))  
matrixM8 <- matrixM8[ , nums]
pairs(matrixM8)
```

```{r, fig.cap= "relatie tussen ESF4 variablen in EAGs met watertype M8", message=FALSE, warning=FALSE, echo = FALSE}
matrixset <- matrix5[,c("EAG","KRWwatertype.code.y","Bedekking Emerse planten_Maatlatten2018 Ov. waterflora","bedemers","taludhoek","CA-1_nf_mg/l","HCO3-1_nf_HCO3_mg/l","Soortensamenstelling macrofyten Hydrofyten_Maatlatten2018 Ov. waterflora")]
matrixM8 <- matrixset[matrixset$KRWwatertype.code.y %in% 'M8',]
nums <- unlist(lapply(matrixM8, is.numeric))  
matrixM8 <- matrixM8[ , nums]
pairs(matrixM8)
```

```{r, fig.cap= "relatie tussen ESF4 variablen in EAGs met watertype M1a", message=FALSE, warning=FALSE, echo = FALSE}
matrixset <- matrix5[,c("EAG","KRWwatertype.code.y","Bedekking Emerse planten_Maatlatten2018 Ov. waterflora","bedemers","taludhoek","CA-1_nf_mg/l","HCO3-1_nf_HCO3_mg/l","Soortensamenstelling macrofyten Hydrofyten_Maatlatten2018 Ov. waterflora")]
matrixM8 <- matrixset[matrixset$KRWwatertype.code.y %in% 'M1a',]
nums <- unlist(lapply(matrixM8, is.numeric))  
matrixM8 <- matrixM8[ , nums]
pairs(matrixM8)
```

```{r, fig.cap= "relatie tussen ESF1 variablen in EAGs met watertype M27", message=FALSE, warning=FALSE, echo = FALSE}
matrixset <- matrix5[,c("EAG","KRWwatertype.code.y","Soortensamenstelling macrofyten _Maatlatten2018 Ov. waterflora","bedsubmers","CHLFA_ug/l", "PvskPDitch","wp_min_sum","nlvrFW")]
matrixM8 <- matrixset[matrixset$KRWwatertype.code.y %in% 'M27',]
nums <- unlist(lapply(matrixM8, is.numeric))  
matrixM8 <- matrixM8[ , nums]
pairs(matrixM8)
```

```{r, fig.cap= "relatie tussen ESF4 variablen in EAGs met watertype M27", message=FALSE, warning=FALSE, echo = FALSE}
matrixset <- matrix5[,c("EAG","KRWwatertype.code.y","Bedekking Emerse planten_Maatlatten2018 Ov. waterflora","bedemers","taludhoek","CA-1_nf_mg/l","HCO3-1_nf_HCO3_mg/l","Soortensamenstelling macrofyten _Maatlatten2018 Ov. waterflora")]
matrixM8 <- matrixset[matrixset$KRWwatertype.code.y %in% 'M27',]
nums <- unlist(lapply(matrixM8, is.numeric))  
matrixM8 <- matrixM8[ , nums]
pairs(matrixM8)
```

*Relatie submerse bedekking en voedselrijkdom waterbodem: Er is te zien dat we een te lage grenswaarde hanteren voor totaal P in de waterbodem. Bij Pmg/kgdg > 1300 worden nog steeds hoge EKRs gemeten (dit is wel op het niveau van EAG, aangenomen dat er geen grote heterogeniteit binnen een EAG bestaat in bodem en vegetatie), er wel een relatie tussen totaal fosfor en sulfide (een maat voor veel zuurstofvraag en afbraak) in de waterbodem en EKR scores. Vooral in wateren met watertype M10.*

*Relatie submerse bedekking en lichtklimaat, er is te zien dat scores pas groter worden dan 0.4 in lijnvormig water bij een doorzicht/diepte- ratio > 0.6 *

*Relatie soortenrijkdom en bedekking en P belasting. Er is te zien dat er in sloten ekr scores op de soortenmaatlat vegetatie > 0.6 worden berekend bij PvskP <2,  dat er in meren ekr scores op de soortenmaatlat vegetatie > 0.6 worden berekend bij PvskP <1, dat er geen relatie bestaat tussen berekende nalevering per EAG en EKR scores per EAG. Alleen in sloten is wel een relatie te zien *

*Relatie emerse bedekking en beschoeiing. Er is te zien dat er hogere EKR scores worden gemeten bij oevers zonder beschoeiing (14), dan met beschoeiing. Behalve in watertype M20*

*Relatie slibdikte en soortensamenstelling vegetatie: Er is te zien dat er bij een slibdikte > 20 cm nooit hoge scores (>0.5) worden bepaald*

*relatie bicarbonaat, calcium en ecologische toestand is opvallend in sloten.*

```{r, echo = FALSE, fig.cap='In dit figuur kan de relatie tussen indicatoren van bepalende processen en de ecologische toestand in beeld worden gebracht.', message= FALSE, warning= FALSE, out.width= "100%", height = "9000px"}
rpivotTable(
    matrix5,
    rows = c("PvskPDitch", "Soortensamenstelling macrofyten Hydrofyten_Maatlatten2018 Ov. waterflora"),
    cols = c("KRWwatertype.code.y","EAG"),
    inclusions = list(KRWwatertype.code.y = list("M8")),
    aggregatorName = "Average",
    rendererName = "Scatter Chart",
    width = 900,
    height = 9000
)
```
